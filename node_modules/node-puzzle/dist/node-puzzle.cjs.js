'use strict';

var PImage = require('pureimage');
var sizeOf = require('image-size');
var nodeUseful = require('node-useful');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var PImage__namespace = /*#__PURE__*/_interopNamespaceDefault(PImage);

const mathPI = Math.PI;
// 拼图点
var Point;
(function (Point) {
    Point[Point["None"] = 0] = "None";
    Point[Point["Outer"] = 1] = "Outer";
    Point[Point["Inner"] = 2] = "Inner"; // 内部
})(Point || (Point = {}));
const pointArray = [Point.None, Point.Outer, Point.Inner];
// 获取随机整数，大于等于0，小于max
function getRandomInt(max, min = 0) {
    return Math.max(Math.floor(Math.random() * max), min);
}
// 随机选择数组中的某一项
function pick(arr) {
    const len = arr.length;
    const randomIndex = getRandomInt(len);
    return arr[randomIndex];
}
// 获取随机拼图点
function getRandomPoints(pointNum) {
    const points = {
        top: pick(pointArray),
        right: pick(pointArray),
        bottom: pick(pointArray),
        left: pick(pointArray)
    };
    const pointsKeys = Object.keys(points);
    const verticalDirs = ['top', 'bottom'];
    const horizontalDirs = ['left', 'right'];
    // console.log('default points: ', points);
    // 保证上下 和 左右 都必须有一个外部的拼图点
    if (points.top === Point.Outer && points.bottom === Point.Outer) {
        points[pick(verticalDirs)] = Point.Inner;
    }
    else if (points.top !== Point.Outer && points.bottom !== Point.Outer) {
        points[pick(verticalDirs)] = Point.Outer;
    }
    if (points.left === Point.Outer && points.right === Point.Outer) {
        points[pick(horizontalDirs)] = Point.Inner;
    }
    else if (points.left !== Point.Outer && points.right !== Point.Outer) {
        points[pick(horizontalDirs)] = Point.Outer;
    }
    if (pointNum) {
        const inners = [];
        const nones = [];
        pointsKeys.forEach((item) => {
            if (points[item] === Point.Inner) {
                inners.push(item);
            }
            else if (points[item] === Point.None) {
                nones.push(item);
            }
        });
        if (pointNum === 2) {
            inners.forEach((item) => (points[item] = Point.None));
        }
        else if (pointNum === 3) {
            if (inners.length === 0) {
                points[pick(nones)] = Point.Inner;
            }
            else if (inners.length === 2) {
                points[pick(inners)] = Point.None;
            }
        }
        else if (pointNum == 4) {
            nones.forEach((item) => (points[item] = Point.Inner));
        }
    }
    // console.log('after points: ', points);
    return points;
}
// 画拼图
function drawPuzzle(ctx, options = {}) {
    const { x = 0, y = 0, w = 60, h = 60 } = options;
    let { points, margin = 0 } = options;
    margin = margin <= 0 ? 0 : margin;
    if (typeof points === 'number' || !points) {
        points = getRandomPoints(points);
    }
    const r = (Math.min(w, h) - margin * 2) * 0.15; // 适合拼图点的比例 0.15
    const l = Math.hypot(r, r); // 斜边长度
    const l1_2 = l / 2; // 斜边长度一半，45度角直角三角形，邻边相等
    const c2r = r + l1_2; // 圆直径
    const rect = {
        x: x + margin,
        y: y + margin,
        w: w - c2r - margin * 2,
        h: h - c2r - margin * 2
    };
    const w1_2 = rect.w / 2; // 矩形一半宽度
    const h1_2 = rect.h / 2; // 矩形一半高度
    if (points.left === Point.Outer) {
        rect.x += c2r;
    }
    if (points.top === Point.Outer) {
        rect.y += c2r;
    }
    ctx.lineWidth = 2;
    // draw start
    ctx.beginPath();
    ctx.moveTo(rect.x, rect.y);
    // console.log('move to coord, x: ', rect.x, ' y: ', rect.y);
    // top
    if (points.top !== Point.None) {
        ctx.lineTo(rect.x + w1_2 - l1_2, rect.y);
        // console.log('line to coord, x: ', rect.x + w1_2 - l1_2, ' y: ', rect.y);
        if (points.top === Point.Inner) {
            ctx.arc(rect.x + w1_2, rect.y + l1_2, r, 1.25 * mathPI, 1.75 * mathPI, true);
        }
        else {
            ctx.arc(rect.x + w1_2, rect.y - l1_2, r, 0.75 * mathPI, 0.25 * mathPI);
        }
    }
    ctx.lineTo(rect.x + rect.w, rect.y);
    // console.log('line to coord, x: ', rect.x + rect.w, ' y: ', rect.y);
    // right
    if (points.right !== Point.None) {
        ctx.lineTo(rect.x + rect.w, rect.y + h1_2 - l1_2);
        // console.log('line to coord, x: ', rect.x + rect.w, ' y: ', rect.y + h1_2 - l1_2);
        if (points.right === Point.Inner) {
            ctx.arc(rect.x + rect.w - l1_2, rect.y + h1_2, r, 1.75 * mathPI, 0.25 * mathPI, true);
        }
        else {
            ctx.arc(rect.x + rect.w + l1_2, rect.y + h1_2, r, 1.25 * mathPI, 0.75 * mathPI);
        }
    }
    ctx.lineTo(rect.x + rect.w, rect.y + rect.h);
    // console.log('line to coord, x: ', rect.x + rect.w, ' y: ', rect.y + rect.h);
    // bottom
    if (points.bottom !== Point.None) {
        ctx.lineTo(rect.x + w1_2 + l1_2, rect.y + rect.h);
        // console.log('line to coord, x: ', rect.x + w1_2 + l1_2, ' y: ', rect.y + rect.h);
        if (points.bottom === Point.Inner) {
            ctx.arc(rect.x + w1_2, rect.y + rect.h - l1_2, r, 0.25 * mathPI, 0.75 * mathPI, true);
        }
        else {
            ctx.arc(rect.x + w1_2, rect.y + rect.h + l1_2, r, 1.75 * mathPI, 1.25 * mathPI);
        }
    }
    ctx.lineTo(rect.x, rect.y + rect.h);
    // console.log('line to coord, x: ', rect.x, ' y: ', rect.y + rect.h);
    // left
    if (points.left !== Point.None) {
        ctx.lineTo(rect.x, rect.y + h1_2 + l1_2);
        // console.log('line to coord, x: ', rect.x, ' y: ', rect.y + h1_2 + l1_2);
        if (points.left === Point.Inner) {
            ctx.arc(rect.x + l1_2, rect.y + h1_2, r, 0.75 * mathPI, 1.25 * mathPI, true);
        }
        else {
            ctx.arc(rect.x - l1_2, rect.y + h1_2, r, 0.25 * mathPI, 1.75 * mathPI);
        }
    }
    ctx.lineTo(rect.x, rect.y);
    // console.log('line to coord, x: ', rect.x, ' y: ', rect.y);
    // ctx.strokeStyle = 'red';
    ctx.stroke();
    // ctx.closePath();
    // ctx.fillStyle = "red";
    // ctx.fill();
    // ctx.strokeRect(x, y, w, h);
}

async function createPuzzle(input, output, options = {}) {
    const { 
    // 拼图
    borderWidth = 1, borderColor = 'rgba(255,255,255,0.7)', fillColor = 'rgba(255,255,255,0.7)', width = 60, height = 60, x: outX, y: outY, margin = 2, equalHeight = true, 
    // 背景图
    bgWidth: outBgWidth, bgHeight: outBgHeight, bgOffset = [0, 0], 
    // 导出配置
    bgImageType = 'jpeg', quality = 80, pngOptions } = options;
    const buffer = await nodeUseful.getBuffer(input);
    const originSizeObj = sizeOf(buffer);
    // console.log('originSizeObj: ', originSizeObj);
    const decodeMethod = originSizeObj.type === 'png' ? PImage__namespace.decodePNGFromStream : PImage__namespace.decodeJPEGFromStream;
    const stream = await nodeUseful.bufferToStream(buffer);
    // 拼图点不支持自定义，默认2个点
    const points = getRandomPoints(2);
    // 原图
    const originImg = await decodeMethod(stream);
    // const originCtx = originImg.getContext('2d');
    const bgWidth = typeof outBgWidth === 'number' && outBgWidth > 0
        ? outBgWidth > width
            ? outBgWidth
            : width
        : originSizeObj.width;
    const bgHeight = typeof outBgHeight === 'number' && outBgHeight > 0
        ? outBgHeight > height
            ? outBgHeight
            : height
        : originSizeObj.height;
    const maxOffsetX = bgWidth - width;
    const maxOffsetY = bgHeight - height;
    let x = typeof outX === 'undefined' ? getRandomInt(maxOffsetX, width) : outX || 0;
    let y = typeof outY === 'undefined' ? getRandomInt(maxOffsetY) : outY || 0;
    if (x < 0) {
        x = 0;
    }
    else if (x > maxOffsetX) {
        x = maxOffsetX;
    }
    if (y < 0) {
        y = 0;
    }
    else if (y > maxOffsetY) {
        y = maxOffsetY;
    }
    // 背景图
    const img = PImage__namespace.make(bgWidth, bgHeight);
    const ctx = img.getContext('2d');
    ctx.clearRect(0, 0, bgWidth, bgHeight);
    ctx.drawImage(originImg, bgOffset[0], bgOffset[1], bgWidth, bgHeight, 0, 0, bgWidth, bgHeight);
    // 拼图
    const puzzleCanvasHeight = equalHeight ? bgHeight : height;
    const puzzleY = equalHeight ? y : 0;
    const puzzle = PImage__namespace.make(width, puzzleCanvasHeight);
    const puzzleCtx = puzzle.getContext('2d');
    puzzleCtx.strokeStyle = borderColor;
    puzzleCtx.lineWidth = borderWidth;
    puzzleCtx.clearRect(0, 0, width, puzzleCanvasHeight);
    drawPuzzle(puzzleCtx, { x: 0, y: puzzleY, w: width, h: height, points, margin });
    puzzleCtx.clip();
    puzzleCtx.drawImage(img, x, y, width, height, 0, puzzleY, width, height);
    // 背景图添加遮罩
    const maskCanvas = PImage__namespace.make(width, height);
    const maskCtx = maskCanvas.getContext('2d');
    maskCtx.clearRect(0, 0, width, height);
    maskCtx.fillStyle = fillColor;
    maskCtx.fillRect(0, 0, width, height);
    drawPuzzle(ctx, { x, y, w: width, h: height, points, margin });
    ctx.clip();
    ctx.drawImage(maskCanvas, x, y, width, height);
    const bgImageTypeIsPng = bgImageType === 'png';
    const bgEncodeMethod = bgImageTypeIsPng ? PImage__namespace.encodePNGToStream : PImage__namespace.encodeJPEGToStream;
    const bgQualityOptions = bgImageTypeIsPng ? pngOptions : quality;
    return Promise.all([
        PImage__namespace.encodePNGToStream(puzzle, output.puzzle, pngOptions),
        // @ts-ignore
        bgEncodeMethod(img, output.bg, bgQualityOptions)
    ]).then(() => {
        return {
            x,
            y: equalHeight ? 0 : y
        };
    });
}

module.exports = createPuzzle;
